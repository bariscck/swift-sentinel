{
  "permissions": {
    "allow": [
      "WebFetch(domain:raw.githubusercontent.com)",
      "WebFetch(domain:api.github.com)",
      "WebFetch(domain:github.com)",
      "Bash(/Users/bariscicek/Desktop/Sentinel/Tests/SentinelTests/IntegrationTests.swift << 'SWIFT_EOF'\nimport Testing\n@testable import SentinelKit\n\nstruct NoForceUnwrapRule: Rule {\n    let identifier = \"no-force-unwrap\"\n    let ruleDescription = \"Avoid force unwrapping optionals.\"\n    let severity: Severity = .warning\n\n    func validate\\(using scope: SentinelScope\\) -> [Violation] {\n        scope.variables\\(includeNested: true\\)\n            .filter { variable in\n                variable.typeAnnotation?.name.hasSuffix\\(\"!\"\\) == true\n            }\n            .map { violation\\(on: $0\\) }\n    }\n}\n\nstruct PublicFinalClassRule: Rule {\n    let identifier = \"public-final-class\"\n    let ruleDescription = \"Public classes should be marked final unless designed for inheritance.\"\n    let severity: Severity = .info\n\n    func validate\\(using scope: SentinelScope\\) -> [Violation] {\n        expect\\(scope.classes\\(\\).withPublicModifier\\(\\)\\) {\n            $0.isFinal\n        }\n    }\n}\n\n@Test func endToEndLinting\\(\\) {\n    let source = \"\"\"\n    public class OpenService {\n        var name: String! = nil\n    }\n\n    public final class ClosedService {\n        let id: Int = 0\n    }\n    \"\"\"\n    let scope = Sentinel.on\\(source: source\\)\n\n    let rules: [any Rule] = [\n        NoForceUnwrapRule\\(\\),\n        PublicFinalClassRule\\(\\),\n    ]\n\n    let runner = RuleRunner\\(rules: rules, scope: scope\\)\n    let violations = runner.run\\(\\)\n\n    let warnings = violations.filter { $0.severity == .warning }\n    let infos = violations.filter { $0.severity == .info }\n    #expect\\(warnings.count == 1\\)\n    #expect\\(infos.count == 1\\)\n}\n\n@Test func diagnosticOutputFormat\\(\\) {\n    let violation = Violation\\(\n        ruleIdentifier: \"test\",\n        message: \"Test message\",\n        severity: .error,\n        filePath: \"/test/File.swift\",\n        line: 10,\n        column: 1\n    \\)\n    let output = XcodeDiagnosticFormatter.format\\(violation\\)\n    #expect\\(output.contains\\(\"error:\"\\)\\)\n    #expect\\(output.contains\\(\"[test]\"\\)\\)\n    #expect\\(output.contains\\(\"File.swift:10:1\"\\)\\)\n}\n\n@Test func compositeRuleChecks\\(\\) {\n    let source = \"\"\"\n    @MainActor class GoodViewModel: BaseViewModel {\n        var name: String = \"\"\n    }\n\n    class BadViewModel {\n        var data: [String]! = nil\n    }\n\n    struct NotAViewModel {}\n    \"\"\"\n    let scope = Sentinel.on\\(source: source\\)\n\n    struct ViewModelRule: Rule {\n        let identifier = \"viewmodel-complete\"\n        let ruleDescription = \"ViewModels must inherit BaseViewModel and be @MainActor.\"\n        let severity: Severity = .error\n\n        func validate\\(using scope: SentinelScope\\) -> [Violation] {\n            let vms = scope.classes\\(\\).withNameEndingWith\\(\"ViewModel\"\\)\n            return expect\\(vms\\) { $0.inherits\\(from: \"BaseViewModel\"\\) }\n                 + expect\\(vms\\) { $0.hasAttribute\\(named: \"MainActor\"\\) }\n        }\n    }\n\n    let rule = ViewModelRule\\(\\)\n    let violations = rule.validate\\(using: scope\\)\n    #expect\\(violations.count == 2\\)\n    #expect\\(violations.allSatisfy { $0.severity == .error }\\)\n}\n\n@Test func severityOrdering\\(\\) {\n    #expect\\(Severity.info < Severity.warning\\)\n    #expect\\(Severity.warning < Severity.error\\)\n    #expect\\(!\\(Severity.error < Severity.warning\\)\\)\n}\nSWIFT_EOF)",
      "Bash(swift build:*)",
      "Bash(swift test:*)",
      "Bash(swift run:*)",
      "Bash(xcodebuild:*)",
      "Bash(swift:*)",
      "Bash(xcrun swift:*)",
      "Bash(ls:*)",
      "Bash(nm:*)",
      "Bash(swiftc:*)"
    ]
  }
}
